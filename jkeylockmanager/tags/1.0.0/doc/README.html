<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Copyright 2009 Marc-Olaf Jaschke
  
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0
 
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License. -->

<head>
	<title>JKeyLockManager</title>
	<style type="text/css">
		* {font-family: verdana, sans-serif; font-size: 12px; font-style: normal; }
		pre {font-family: monospace; }
		h1 {font-size: 1.5em;}
		h2 {font-size: 1.3em; margin-top: 2.5em; }
		h3 {font-size: 1.2em; margin-top: 2em; }
		p {text-align: justify; }
		em {font-style: italic; }
		q {font-style: italic; }
		code {color: #003366; }
		abbr {font-size: inherit; }
		dl.imgleft {float: none; margin-bottom: 2em; margin-top: 2em; }
		dl.imgleft dt {margin-bottom: 1em; }
		dl.imgleft dd {margin: 0; font-style: italic; font-size: 0.8em; text-align: right; }
	</style>
</head>

<body>

<h1>JKeyLockManager</h1>
<p>
JKeyLockManager (<abbr>KLM</abbr>) provides fine-grained locking with application specific keys. 
All resource and exception handling for the active set of keys is encapsulated in the manager.
Thereby it is easier to follow the recommendation of Robert C. Martin:
<q>Keep your concurrency-related code separate from other code.</q>
</p>

<h2>Abstract</h2>
<p>
The <abbr>KLM</abbr> offers the possibility of performing callbacks within a lock. It selects the lock on the basis of a given key.
</p>
<pre>
...
manager.executeLocked("test1", new LockCallback() {
	public void doInLock() {
		...
	}
});
</pre>
<p>
The <abbr>KLM</abbr> takes over the maintenance of the locks and keys completely. It can manage arbitrary quantities of keys and locks. 
One lock is assigned to each key and the necessary locks are produced automatically.<br />
The <abbr>KLM</abbr> ensures that unneeded keys and locks are being released quickly.
</p>

<h2>Behavior with concurrency</h2>
<dl class="imgleft" style="width: 360px;">
	<dt><img src="lock-chart.gif" alt="lock chart" /></dt>
	<dd>Figure 1: lock chart</dd>
</dl>
<p>
If a thread executes a callback with a key <em>A</em>, a second thread can execute a callback with a key <em>B</em> <em>concurrently</em>. 
Another thread, which is trying to execute a callback with a key <em>A</em>, has to wait until the first thread leaves the callback.
</p>
<p>
The methods of the <abbr>KLM</abbr> are reentrant and interruptible.
</p>

<h2>Example - web service with concurrency constraint</h2>
<p>
A local system exports weather data to a distributed web service. The service is called for a large set of cities and every service access for a city has a high response time. 
Since the service is made available on a cluster, the import can be strongly accelerated by concurrent access.
The service forbids concurrent access to the weather data of the <em>same</em> city. A simple lock is used in order to ensure compliance with this constraint.
</p>

<h3>A simple solution with a global lock</h3>
<pre>
public class WeatherServiceProxy {
...
public synchronized void updateWeatherData(String cityName, Date samplingTime, float temperature) {
	delegate.updateWeatherData(cityName, samplingTime, temperature);
}
...
</pre>
<p>
<em>Problem:</em> The speedup is completely lost for compliance with the constraint. Concurrent access is even blocked for <em>different</em> city names. We need a finer grained lock.
</p>

<h3>Solution with <abbr>KLM</abbr></h3>
<pre>
public class WeatherServiceProxy {
...
private final KeyLockManager lockManager = KeyLockManagers.newManager();

public void updateWeatherData(String cityName, Date samplingTime, float temperature) {
	lockManager.executeLocked(cityName, new LockCallback() {
		public void doInLock() {
			delegate.updateWeatherData(cityName, samplingTime, temperature);
		}
	});
}
...
</pre>
<p>
Now threads that work on weather data from different cities can enter the locked section concurrently. 
Compliance with the constraint <em>and</em> speedup has been achieved.  
</p>

<h2>Getting started</h2>
<p>
Start with <code>KeyLockManagers</code> in order to get instances of <abbr>KLM</abbr>.
</p>

</body>
</html>